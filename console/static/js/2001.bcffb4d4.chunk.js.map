{"version":3,"file":"static/js/2001.bcffb4d4.chunk.js","mappings":"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","sources":["../node_modules/@aserto/console-common/dist/index-a28a3aa8.js"],"sourcesContent":["/** @private */\nfunction extendedTypeof(val) {\n    if (val === null) {\n        return 'null';\n    }\n    if (Array.isArray(val)) {\n        return 'array';\n    }\n    return typeof val;\n}\n/** @private */\nfunction isObject(val) {\n    return extendedTypeof(val) === 'object';\n}\n/** @private */\nfunction areGraphQLErrors(obj) {\n    return (Array.isArray(obj) &&\n        // must be at least one error\n        obj.length > 0 &&\n        // error has at least a message\n        obj.every((ob) => 'message' in ob));\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */\nfunction limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n}\n\n/**\n *\n * common\n *\n */\n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n *\n * @category Common\n */\nconst GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n *\n * @category Common\n */\nvar CloseCode;\n(function (CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */\n    CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */\n    CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n})(CloseCode || (CloseCode = {}));\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n})(MessageType || (MessageType = {}));\n/**\n * Validates the message against the GraphQL over WebSocket Protocol.\n *\n * Invalid messages will throw descriptive errors.\n *\n * @category Common\n */\nfunction validateMessage(val) {\n    if (!isObject(val)) {\n        throw new Error(`Message is expected to be an object, but got ${extendedTypeof(val)}`);\n    }\n    if (!val.type) {\n        throw new Error(`Message is missing the 'type' property`);\n    }\n    if (typeof val.type !== 'string') {\n        throw new Error(`Message is expects the 'type' property to be a string, but got ${extendedTypeof(val.type)}`);\n    }\n    switch (val.type) {\n        case MessageType.ConnectionInit:\n        case MessageType.ConnectionAck:\n        case MessageType.Ping:\n        case MessageType.Pong: {\n            if (val.payload != null && !isObject(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object or nullish or missing, but got \"${val.payload}\"`);\n            }\n            break;\n        }\n        case MessageType.Subscribe: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!isObject(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);\n            }\n            if (typeof val.payload.query !== 'string') {\n                throw new Error(`\"${val.type}\" message payload expects the 'query' property to be a string, but got ${extendedTypeof(val.payload.query)}`);\n            }\n            if (val.payload.variables != null && !isObject(val.payload.variables)) {\n                throw new Error(`\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.variables)}`);\n            }\n            if (val.payload.operationName != null &&\n                extendedTypeof(val.payload.operationName) !== 'string') {\n                throw new Error(`\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${extendedTypeof(val.payload.operationName)}`);\n            }\n            if (val.payload.extensions != null && !isObject(val.payload.extensions)) {\n                throw new Error(`\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.extensions)}`);\n            }\n            break;\n        }\n        case MessageType.Next: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!isObject(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Error: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            if (!areGraphQLErrors(val.payload)) {\n                throw new Error(`\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);\n            }\n            break;\n        }\n        case MessageType.Complete: {\n            if (typeof val.id !== 'string') {\n                throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);\n            }\n            if (!val.id) {\n                throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n            }\n            break;\n        }\n        default:\n            throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n    }\n    return val;\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */\nfunction parseMessage(data, reviver) {\n    return validateMessage(typeof data === 'string' ? JSON.parse(data, reviver) : data);\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */\nfunction stringifyMessage(msg, replacer) {\n    validateMessage(msg);\n    return JSON.stringify(msg, replacer);\n}\n\n/**\n *\n * client\n *\n */\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nfunction createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting');\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send(stringifyMessage({ type: MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send(stringifyMessage(payload\n                        ? {\n                            type: MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = parseMessage(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send(stringifyMessage(message.payload\n                                ? {\n                                    type: MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(() => {\n                                if (socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeoutMs);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    CloseCode.InternalServerError,\n                    CloseCode.InternalClientError,\n                    CloseCode.BadRequest,\n                    CloseCode.BadResponse,\n                    CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    CloseCode.SubscriberAlreadyExists,\n                    CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    return {\n        on: emitter.on,\n        subscribe(payload, sink) {\n            const id = generateID(payload);\n            let done = false, errored = false, releaser = () => {\n                // for handling completions before connect\n                locks--;\n                done = true;\n            };\n            (async () => {\n                locks++;\n                for (;;) {\n                    try {\n                        const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                        // if done while waiting for connect, release the connection lock right away\n                        if (done)\n                            return release();\n                        const unlisten = emitter.onMessage(id, (message) => {\n                            switch (message.type) {\n                                case MessageType.Next: {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                                    sink.next(message.payload);\n                                    return;\n                                }\n                                case MessageType.Error: {\n                                    (errored = true), (done = true);\n                                    sink.error(message.payload);\n                                    releaser();\n                                    return;\n                                }\n                                case MessageType.Complete: {\n                                    done = true;\n                                    releaser(); // release completes the sink\n                                    return;\n                                }\n                            }\n                        });\n                        socket.send(stringifyMessage({\n                            id,\n                            type: MessageType.Subscribe,\n                            payload,\n                        }, replacer));\n                        releaser = () => {\n                            if (!done && socket.readyState === WebSocketImpl.OPEN)\n                                // if not completed already and socket is open, send complete message to server on release\n                                socket.send(stringifyMessage({\n                                    id,\n                                    type: MessageType.Complete,\n                                }, replacer));\n                            locks--;\n                            done = true;\n                            release();\n                        };\n                        // either the releaser will be called, connection completed and\n                        // the promise resolved or the socket closed and the promise rejected.\n                        // whatever happens though, we want to stop listening for messages\n                        await waitForReleaseOrThrowOnClose.finally(unlisten);\n                        return; // completed, shouldnt try again\n                    }\n                    catch (errOrCloseEvent) {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                }\n            })()\n                .then(() => {\n                // delivering either an error or a complete terminates the sequence\n                if (!errored)\n                    sink.complete();\n            }) // resolves on release or normal closure\n                .catch((err) => {\n                sink.error(err);\n            }); // rejects on close events and errors\n            return () => {\n                // dispose only of active subscriptions\n                if (!done)\n                    releaser();\n            };\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', {\n                    code: 4499,\n                    reason: 'Terminated',\n                    wasClean: false,\n                });\n            }\n        },\n    };\n}\nfunction isLikeCloseEvent(val) {\n    return isObject(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000,\n        1001,\n        1006,\n        1005,\n        1012,\n        1013,\n        1013, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n\nexport { CloseCode, GRAPHQL_TRANSPORT_WS_PROTOCOL, MessageType, createClient, parseMessage, stringifyMessage, validateMessage };\n"],"names":["extendedTypeof","val","Array","isArray","isObject","limitCloseReason","reason","whenTooLong","length","GRAPHQL_TRANSPORT_WS_PROTOCOL","CloseCode","MessageType","validateMessage","Error","type","ConnectionInit","ConnectionAck","Ping","Pong","payload","Subscribe","id","query","variables","operationName","extensions","Next","obj","every","ob","JSON","stringify","Complete","stringifyMessage","msg","replacer","createClient","options","url","connectionParams","lazy","onNonLazyError","console","error","lazyCloseTimeout","lazyCloseTimeoutMs","keepAlive","disablePong","connectionAckWaitTimeout","retryAttempts","retryWait","async","retries","retryDelay","i","Promise","resolve","setTimeout","Math","floor","random","shouldRetry","isLikeCloseEvent","isFatalConnectionProblem","on","webSocketImpl","generateID","replace","c","r","toString","jsonMessageReplacer","jsonMessageReviver","reviver","ws","WebSocket","global","MozWebSocket","window","WebSocketImpl","emitter","message","listeners","listener","emit","_a","call","connecting","opened","connected","ping","pong","closed","onMessage","event","l","push","splice","indexOf","_len","arguments","args","_key","errorOrClosed","cb","listening","err","forEach","unlisten","locks","retrying","disposed","connect","clearTimeout","socket","throwOnClose","denied","undefined","code","connectionAckTimeout","queuedPing","enqueuePing","isFinite","readyState","OPEN","send","errOrEvent","close","onerror","onclose","onopen","ConnectionAcknowledgementTimeout","InternalClientError","acknowledged","onmessage","_ref","data","parse","parseMessage","_","reject","BadResponse","CLOSING","release","released","race","then","complete","shouldRetryConnectOrThrow","errOrCloseEvent","includes","InternalServerError","BadRequest","Unauthorized","SubprotocolNotAcceptable","SubscriberAlreadyExists","TooManyInitialisationRequests","subscribe","sink","done","errored","releaser","waitForReleaseOrThrowOnClose","next","finally","catch","dispose","terminate","wasClean"],"sourceRoot":""}